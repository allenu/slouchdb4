# SlouchDB4

SlouchDB4 is a CRDT-style distributed journal-based database for single-user/multi-device scenarios. It is written in Swift and
so is currently only available for macOS and iOS clients.

# How it Works

SlouchDB4 lets you write an app that saves diff changes to its own local journal. It can interop with a shared file storage
(such as Dropbox, OneDrive, iCloud) and upload its own journal files as well as download journal files generated by other
clients. It will then merge the remote changes into its local journal history to update the state of the database.

# Why single-user/multi-device?

This database is meant for single-user only because it uses a very primitive conflict-resolution system: the last update wins.
Additionally, the clock it uses to order edits across multiple platforms is not synchronized. It is assumed that each peer
uses a clock that's "pretty close" to the other peers. In other words, we are relying on a single user to be slow enough in
making edits across multiple devices that clock synchronization is not an issue.

# History

This is a rewrite of [SlouchDB](https://github.com/allenu/slouchdb). It is the 4th version. [SlouchDB2](https://github.com/allenu/slouchdb2) was another attempt and was being updated as well as used in my own personal apps. However, I soon noticed it would not scale to
large databases since all data was loaded into memory. I wanted it to support massive databases and ensure everything could be
stored to disk and cached in-mem only as necessary. SlouchDB3 (never released) was started to handle this at the beginning of
January 2020. After a couple of weeks of implementation, I realized the architecture could be even more improved, so rewrote it
again before it got too far. Hence, SlouchDB4.

# WIP

This is a work in progress. See TODOs.md for regular updates (adding of new tasks as well as marking old tasks done). It's in
a pre-alpha stage, but progress is being made quickly. Short term goals:

- get PeopleApp example app (from SlouchDB v1 and v2) building and running again on macOS and iOS using SlouchDB4
- wrap everything up in a CocoaPod
- test it out with a massive list of diffs and large data to verify that it has small mem footprint and is fast

--------------------------------------------------------------------------------
# How to Use it

ChangeTracker acts as proxy to your database, but only for writes. When you would normally write to your database
(be it inserting a new item, updating an existing item, or deleting an existing item), instead of doing it on the
database directly, you encode a command that contains all the details of the mutation operation and provide it to
the ChangeTracker object. It will then store this info in a local journal. After storing it in the local journal,
it will then call your delegate to request the command you provided earlier is executed. When this command is
executed is up to the ChangeTracker, but generally it will execute it as soon as possible.

Other peers which are also using ChangeTracker, but on different devices, will generate their own journals that
describe the commands they execute to do mutations. When ChangeTracker does a sync, it will push the latest
version of these journals to a common "remote repo". Each ChangeTracker also periodically downloads the latest
version of these journals as well.

To make use of the remote journals, ChangeTracker merges all commands from all journals and sequences them in order
for each object. It then calls the client to re-constitute these objects using the merged and sequenced commands.

## High-level Best Practices

- Avoid chained operations where one mutation would lead to another mutation. If you have a system where
  causing a change to object A causes a change to object B, this can cause additional journal commands to be
  created. This can grow the journal size. If possible, object B should be dynamically re-generated on the fly
  without having to write to the database. 

- Data that changes frequently and doesn't necessarily need to be shared across peers should not be saved to
  the common journal. For instance, if you are storing the user's selection of a list of items, every time you
  move around the list, a command will be added to journal, quickly growing it in size. This type of setting
  could just be saved to the local device to avoid growing the journal. Another option is to only save the
  setting when the user exits the app, instead of whenever the selection changes.

## Creating ChangeTracker
- Instantiate ChangeTracker and pass in a JournalManager and an ObjectHistoryStore
  - JournalManager takes care of pulling and pushing journals to the shared remote
  - ObjectHistoryStore takes care of storing a full history of all commands for each "object" in the system

## How ChangeTracker Calls You
- Assign a delegate to the ChangeTracker. It is responsible for executing a list of commands provided to it for
  a given object. The delegate method for executing commands will always be called on the same object.
  - the request(s) for executing commands will always be wrapped by matching beginCommandExecution() and endCommandExecution()
    - this is to allow you to batch multiple changes together. For instance, you may wish to only update the UI once
      all calls to execute commands are done.
    - you might see a sequence of delegate callbacks like this:

        beginCommandExecution()
        execute(commands:,for:,startingAt:,completion:)
        execute(commands:,for:,startingAt:,completion:)
        execute(commands:,for:,startingAt:,completion:)
        execute(commands:,for:,startingAt:,completion:)
        execute(commands:,for:,startingAt:,completion:)
        endCommandExecution()

  - the list of commands provided will either start from the beginning of all commands (starting at PlaybackPosition.start), or
    appending onto the current state of the object (starting at PlaybackPosition.currentPosition)
    - you must be able to handle both scenarios

  - the Command struct provides common info and a special payload (operation Data property)
    - objectIdentifier -- which object this command is targeting
    - commandIdentifier -- a UUID that uniquely identifies this command
    - timestamp -- when the command was originally issued
    - operation -- Data defined by you, which describes what command actually "is"

  - generally, the operation Data will be serialized data that you deserialize (for instance via JSONDecoder) into a struct


## How to send commands to ChangeTracker

- create a Command object
- call changeTracker.append(command: command, completion: {})


# Queues

- ChangeTracker uses its own background queue for executing tasks
- when client is called to execute a command, feel free to execute those tasks in a background thread of your choosing.
  You must call the completion block to notify ChangeTracker that the task has completed.

  Assume that your execute() handler is called in a background thread.

  If you need to execute code in another thread in your execute handler, just make sure the completion block is called
  only until all async code you issue is complete.


# Completion Blocks

All commands issued to ChangeTracker are processed asynchronously and there is no guarantee on how quickly they will be 
executed. To ensure clients can run code that depends on the command being executed, you may provide a completion block
to append(). When the command is executed, the completion block is called.



# --------------------------------------------------------------------------------
# How ChangeTracker Maintains State

When append() is called, the command goes into a local journal.
The command is also added to an unprocessedCommands list.
The command processor is started if it is inactive.
The command processor operates in its own dispatch queue. Only one processor runs at a time.
A run of the processor works like this:
    - enqueue the unprocessedCommands into the ObjectHistoryTracker. this causes the commands
      to be permanently stored in the full list of commands for the given object they are
      affecting. (i.e. take the objectIdentifier of the command). Commands are stored in
      sort order based on timestamp). One other piece of info is stored when the new command
      is added:

        - if the command is just appended to the existing command list, it is treated as
          a fast-forward change. This info is used in the pending update process stage
          below. (If the command list is already treated as a replay change, it is not
          changed.)

        - if the command is inserted into the existing command list, it is treated as
          a replay change. The entire command list is replayed for the object during
          the pending update phase.

    - the ObjectHistoryTracker then marks the object as needing an update

    - after all the commands are stored in the tracker and pending updates are recorded, 
      each object that has pending updates is enumerated:

      - if the command list change is a fast forward, all new commands past the nextCommandIndex
        are processed

      - if it is a replay, all commands from the beginning are processed.

      - call the commandExecutor delegate to process the list of commands as a group, but
        asynchronously

    - once all commands in all objects are executed, finish processing by calling the completion
      blocks on all commands appended

--------------------------------------------------------------------------------
# Generating a journal from an existing database

There may be cases you need to spit out a local journal based on a database that has already been
created, one that wasn't created with the journal.

To do so requires some care since the normal process mentioned above where append() is called with
the journal commands causes the command to be immediately executed.

To generate a local journal without executing the commands and just treating them as "already executed"
within ObjectHistoryTracker, do the following after first ensuring that the changeTracker is not syncing
and that it is empty:

    changeTracker.manuallyResetHistory(for: objectIdentifier, commands: commands)

This will cause the following:

    - changeTracker will add the command to its local journal
    - objectHistoryTracker will update its internal history for that object to match the commands list
      AND treat them as having been processed

From this point on, if an append() is called on the objectIdentifier, it will be correctly handled.

